# pymport

Use Python libraries from Node.js

# Status

Not ready

# Usage

Directly use the raw `PyObject` object:

```js
import { pymport } from "pymport";

// Python: import numpy as np
// np is a PyObject
const np = pymport("numpy");

// Python: a = np.arange(15).reshape(3, 5)
// a is a PyObject
const a = np.get("arange").call(15).get("reshape").call(3, 5);

// Python: a = np.ones((2, 3), dtype=int16)
// np.get('int16') is a PyObject
const b = np.get("ones").call([2, 3], { dtype: np.get("int16") });

// Python: print(a.tolist())
// PyObject.toJS() converts to JS
console.log(a.get("tolist").call().toJS());
```

With `proxify`:

```js
import { pymport, proxify } from "pymport";

// Python: import numpy as np
// np is a normal JS object
const np = proxify(pymport("numpy"));

// Python: a = np.arange(15).reshape(3, 5)
// a is a PyObject
const a = np.arange(15).reshape(3, 5);

// Python: a = np.ones((2, 3), dtype=int16)
// np.int16 is a callable PyFunction
const b = np.ones([2, 3], { dtype: np.int16 });

console.log(a.tolist().toJS());
```

Even the most perverted pandas syntax can be expressed:

```js
// df = pd.DataFrame(np.arange(15).reshape(5, 3), columns=list(['ABC']) })
const df = pd.DataFrame(np.arange(15).reshape(5, 3), {
  columns: PyObject.list(["A", "B", "C"]),
});
assert.deepEqual(df.columns.tolist().toJS(), ["A", "B", "C"]);

// df[2:3]
// In Python this is equivalent to df.__getitem__(2:3)
const df2 = df.__getitem__(PyObject.slice([2, 3, null]));
assert.deepEqual(df2.values.tolist().toJS(), [[6, 7, 8]]);

// df[df["C"] <= 3]
// In Python this is equivalent to df.__getitem__(df.__getitem__("C").__le__(3))
const df3 = df.__getitem__(df.__getitem__("C").__le__(3));
assert.deepEqual(df3.values.tolist().toJS(), [[0, 1, 2]]);
```

# API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

*   [callable](#callable)
*   [type](#type)
*   [get](#get)
    *   [Parameters](#parameters)
*   [has](#has)
    *   [Parameters](#parameters-1)
*   [call](#call)
    *   [Parameters](#parameters-2)
*   [toJS](#tojs)
*   [toString](#tostring)
*   [int](#int)
    *   [Parameters](#parameters-3)
*   [float](#float)
    *   [Parameters](#parameters-4)
*   [string](#string)
    *   [Parameters](#parameters-5)
*   [dict](#dict)
    *   [Parameters](#parameters-6)
*   [list](#list)
    *   [Parameters](#parameters-7)
*   [tuple](#tuple)
    *   [Parameters](#parameters-8)
*   [slice](#slice)
*   [fromJS](#fromjs)
    *   [Parameters](#parameters-9)
*   [pymport](#pymport)
    *   [Parameters](#parameters-10)
*   [proxify](#proxify)
    *   [Parameters](#parameters-11)

## callable

Is the property callable

Type: boolean

## type

The underlying Python type

Type: string

## get

Get a property from the object

Type: function (name: string): PyObject

### Parameters

*   `name` **string** property name

Returns **PyObject**&#x20;

## has

Check if a property exists

Type: function (name: string): boolean

### Parameters

*   `name` **string** property name

Returns **boolean**&#x20;

## call

Call a callable property from the object

Type: function (...args: Array\<any>): PyObject

### Parameters

*   `args` **...Array\<any>** function arguments

Returns **PyObject**&#x20;

## toJS

Transform the PyObject to a plain JS object

Type: function (): any

Returns **any**&#x20;

## toString

Use the Python str() built-in on the object

Type: function (): string

Returns **string**&#x20;

## int

Construct a PyObject integer from a JS number

Type: function (v: number): PyObject

### Parameters

*   `number` **number**&#x20;

Returns **PyObject**&#x20;

## float

Construct a PyObject float from a JS number

Type: function (v: number): PyObject

### Parameters

*   `number` **number**&#x20;

Returns **PyObject**&#x20;

## string

Construct a PyObject string from a JS string

Type: function (v: string): PyObject

### Parameters

*   `string` **string**&#x20;

Returns **PyObject**&#x20;

## dict

Construct a PyObject dictionary from a JS object

Type: function (v: Record\<string, any>): PyObject

### Parameters

*   `object` **Record\<string, any>**&#x20;

Returns **PyObject**&#x20;

## list

Construct a PyObject list from a JS array

Type: function (v: Array\<any>): PyObject

### Parameters

*   `array` **Array\<any>**&#x20;

Returns **PyObject**&#x20;

## tuple

Construct a PyObject tuple from a JS array

Type: function (v: Array\<any>): PyObject

### Parameters

*   `array` **Array\<any>**&#x20;

Returns **PyObject**&#x20;

## slice

Construct a PyObject slice from three elements (start, stop, step)

Type: function (v: any): PyObject

Returns **PyObject**&#x20;

## fromJS

Construct an automatically typed PyObject from a plain JS value

Type: function (v: any): PyObject

### Parameters

*   `value` **any**&#x20;

Returns **PyObject**&#x20;

## pymport

Import a Python module

### Parameters

*   `name` **string** Python module name

Returns **PyObject**&#x20;

## proxify

Create a profixied version of a PyObject
that works like a native Python object

### Parameters

*   `v` **PyObject**&#x20;
*   `object` **PyObject** object to proxify

Returns **any**&#x20;

# Alternatives

There is an alternative package that is more mature but with slightly different target use called [`node-calls-python`](https://github.com/hmenyus/node-calls-python).

`node-calls-python` is geared towards calling large monolithic Python subroutines. It supports asynchronous calling as it is expected that those will take significant amount of CPU time. `node-calls-python` does type conversions on each call.

`pymport` is geared towards intensive use of Python libraries in Node.js. It may support asynchronous calling in the future. The main difference is that `pymport` keeps the `PyObject` objects visible in JavaScript. For example, it allows creating a `numpy` array, then using the various `numpy` methods without converting the array back to JavaScript.
